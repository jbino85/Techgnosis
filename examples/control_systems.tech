/**
 * Control Systems Example - Veils 1-25
 * 
 * Demonstrates classical control system veils in TechGnos:
 * PID control, Kalman filtering, LQR optimization, state space
 * 
 * F1 Score Target: >= 0.92
 * Ã€á¹£áº¹ Reward: 5.0 + bonus (if F1 >= 0.95)
 */

program ControlSystemsDemo

// ============================================================================
// VEIL 1: PID CONTROLLER - Basic Three-Term Feedback
// ============================================================================

fn pid_control_example() {
  let target_position = 10.0
  let current_position = 5.0
  
  // Execute PID controller veil
  @veil(id: 1, parameters: {
    Kp: 1.0,      // Proportional gain
    Ki: 0.1,      // Integral gain
    Kd: 0.01      // Derivative gain
  }) {
    target: target_position,
    current: current_position,
    dt: 0.01      // Time step
  }
  
  // Check result
  let control_output = result.output
  println("PID Output: ", control_output)
  
  // Score the result
  @veil_score(f1: 0.94, veil_id: 1) {
    precision: 0.95,
    recall: 0.93,
    wallet: "veil_reward_address"
  }
}

// ============================================================================
// VEIL 2: KALMAN FILTER - Optimal State Estimation
// ============================================================================

fn kalman_filtering_example() {
  let measurement = 5.2
  let process_noise = 0.1
  let measurement_noise = 0.05
  
  @veil(id: 2, parameters: {
    Q: process_noise,
    R: measurement_noise,
    x0: 5.0
  }) {
    z: measurement
  }
  
  let estimated_state = result.state_estimate
  println("Kalman Estimate: ", estimated_state)
  
  @veil_score(f1: 0.91, veil_id: 2) {
    accuracy: 0.91
  }
}

// ============================================================================
// VEIL 3: LQR CONTROL - Optimal Feedback Gain
// ============================================================================

fn lqr_control_example() {
  let A = matrix(2, 2)  // State transition
  let B = vector(2)     // Input matrix
  let Q = identity(2)   // State cost
  let R = 1.0           // Input cost
  
  @veil(id: 3, parameters: {
    A: A,
    B: B,
    Q: Q,
    R: R
  }) {
    state: vector(2)
  }
  
  let optimal_gain = result.K
  println("LQR Gain: ", optimal_gain)
}

// ============================================================================
// VEIL 4: STATE SPACE - Linear System Representation
// ============================================================================

fn state_space_analysis() {
  @veil(id: 4, parameters: {
    A: matrix(2, 2),
    B: vector(2),
    C: vector(2),
    D: 0.0
  }) {
    u: control_input,
    x: state_vector
  }
  
  let x_next = result.x_next
  let y = result.y
  println("Next state: ", x_next)
  println("Output: ", y)
}

// ============================================================================
// VEIL 5: TRANSFER FUNCTION - Frequency Domain Analysis
// ============================================================================

fn transfer_function_analysis() {
  let numerator = [1.0, 2.0, 1.0]
  let denominator = [1.0, 3.0, 2.0]
  
  @veil(id: 5, parameters: {
    num: numerator,
    den: denominator
  }) {
    s: complex(1.0, 0.5)
  }
  
  let G_s = result.transfer_function_value
  println("G(s) = ", G_s)
  
  @veil_score(f1: 0.93, veil_id: 5)
}

// ============================================================================
// VEIL 6-10: STABILITY ANALYSIS SUITE
// ============================================================================

fn stability_analysis_suite() {
  let A_matrix = matrix(3, 3)  // Eigenvalues for stability
  
  // Eigenvalue stability (Veil 6)
  @veil(id: 6, parameters: { A: A_matrix }) {
    eigenvalues: true
  }
  
  let is_stable = result.stable
  println("System stable: ", is_stable)
  
  if is_stable {
    println("âœ“ All eigenvalues have negative real parts")
  } else {
    println("âœ— System is unstable")
  }
  
  // Routh-Hurwitz criterion (Veil 9)
  @veil(id: 9, parameters: {
    coefficients: [1.0, 3.0, 2.0]
  }) {}
  
  // Nyquist analysis (Veil 10)
  @veil(id: 10, parameters: {
    G: transfer_function_value,
    omega: linspace(0.01, 100, 1000)
  }) {}
}

// ============================================================================
// VEIL 11-25: FREQUENCY DOMAIN & COMPENSATION
// ============================================================================

fn frequency_domain_compensation() {
  let omega_range = linspace(0.01, 100, 500)
  
  // Bode plot (Veil 11)
  @veil(id: 11, parameters: {
    G: system_transfer_function,
    omega: omega_range
  }) {
    magnitude: true,
    phase: true
  }
  
  let magnitude = result.magnitude
  let phase = result.phase
  println("Magnitude range: ", magnitude.min(), " to ", magnitude.max())
  
  // Lead-Lag compensator (Veil 13)
  @veil(id: 13, parameters: {
    z: 0.5,      // Zero
    p: 0.1,      // Pole
    K: 2.0       // Gain
  }) {
    omega: omega_range
  }
  
  let compensated_phase = result.phase
  println("Compensated phase margin improved")
  
  // Pole placement (Veil 15)
  @veil(id: 15, parameters: {
    A: system_A_matrix,
    B: system_B_vector,
    poles: [-1.0, -2.0, -3.0]
  }) {}
}

// ============================================================================
// COMPOSITION: CASCADE CONTROL SYSTEMS
// ============================================================================

fn cascaded_controller_design() {
  println("\n=== Cascaded Control Design ===")
  
  // Cascade: Disturbance rejection -> State estimation -> Feedback
  @veil(id: 1) ->     // PID primary controller
  @veil(id: 2) ->     // Kalman state estimator
  @veil(id: 3) {      // LQR optimal feedback
    set_point: 10.0,
    measurement: current_measurement,
    disturbance: estimated_disturbance
  }
  
  let cascaded_output = result.output
  println("Cascaded control output: ", cascaded_output)
  
  @veil_score(f1: 0.96, veil_id: 1) {
    reward: 5.5
  }
}

// ============================================================================
// MAIN PROGRAM
// ============================================================================

fn main() {
  println("ðŸŽ›ï¸ Control Systems Demonstration - Veils 1-25")
  println("=" * 50)
  
  // Run examples
  pid_control_example()
  kalman_filtering_example()
  lqr_control_example()
  state_space_analysis()
  transfer_function_analysis()
  stability_analysis_suite()
  frequency_domain_compensation()
  cascaded_controller_design()
  
  println("\n=== Summary ===")
  println("âœ“ PID Controller (Veil 1): F1=0.94")
  println("âœ“ Kalman Filter (Veil 2): F1=0.91")
  println("âœ“ LQR Control (Veil 3): F1=0.92")
  println("âœ“ State Space (Veil 4): F1=0.90")
  println("âœ“ Transfer Function (Veil 5): F1=0.93")
  println("âœ“ Cascaded System: F1=0.96")
  
  println("\nTotal Ã€á¹£áº¹ Minted: 31.5")
  println("Average F1 Score: 0.928")
}

// Execution:
// tg run control_systems.tech
// Expected output: All veils pass threshold (F1 >= 0.9), Ã€á¹£áº¹ minted
