# ZÃ ngbÃ©tÃ² v1.0 â€” Atá»ÌmÃ­ áº¸Ì€kÃ³ Kan (Atomic Mono-Repo: Immune + Shrine)

**áº¸Ì€kÃ³ á»ŒÌ€rÃ­ | Unified Smart Contract Guardian System**

```
One repo. Two rituals. Infinite dances.

Immune (Python masks) â†’ Receipts (v2.1 schema) â†’ Shrine (Sui Move) â†’ Arweave â†’ Bitcoin SPV
                                                                              â†“
                                                                        Witness Attestation
                                                                              â†“
                                                                        Weekly Sabbath Seal

ğŸ”¥ğŸŒ€ğŸ•¯ï¸
```

---

## I. á»ŒÌ€rÃ­ ÃŒjáº¹Ì (Foundation Truth)

**What This Is:**

A single atomic mono-repo that fuses:
- **Immune** (off-chain): Python ritual veils (1, 4, 6) + cadence + receipt logger
- **Shrine** (on-chain): Sui Move ledger + witness governance + Arweave anchoring
- **Shared** (both): Receipt schema v2.1, Elder registry, beacon (SPV), security bounds

**The Dance Flow:**

```
1. Immune: Veils patrol â†’ emit receipts (JSON, masked, schema-valid)
2. Receipts: Validated, signed by 3+ Elders â†’ stored in immune/receipts/out/
3. Shrine: Scripts anchor â†’ Arweave, OTS timestamp â†’ submit on-chain
4. On-Chain: Receipts ledger records + witnesses attest status changes
5. Sabbath: Weekly ceremony â†’ collect â†’ filter â†’ attest â†’ patch â†’ seal
```

---

## II. áº¸Ì€kÃ³ RÃ¹n ÃŒpÃ¬láº¹Ì€ (Atomic Repo Layout)

```
zangbeto/
â”‚
â”œâ”€ Makefile                          # Top-level orchestration (patrol â†’ anchor â†’ submit â†’ sabbath)
â”œâ”€ .env.example                      # Config template
â”œâ”€ README.md                         # Quickstart
â”‚
â”œâ”€ immune/                           # Off-chain ritual immune body (Python)
â”‚  â”œâ”€ masks/
â”‚  â”‚  â”œâ”€ veil1_ifa_bones.py          # Bone divination mask (structural analysis)
â”‚  â”‚  â”œâ”€ veil4_temple_codes.py       # Temple code mask (rational invariants)
â”‚  â”‚  â””â”€ veil6_chaos_fractals.py     # Chaos mask (entropy detection)
â”‚  â”‚
â”‚  â”œâ”€ cadence/
â”‚  â”‚  â”œâ”€ vrf_scheduler.js            # VRF-seeded jitter scheduler (replace with your VRF)
â”‚  â”‚  â””â”€ sabbath_witness.js          # Weekly seal orchestration
â”‚  â”‚
â”‚  â”œâ”€ sandbox/
â”‚  â”‚  â”œâ”€ run_with_limits.py          # CPU/memory/wall enforcer per mask
â”‚  â”‚  â”œâ”€ containment_manifest.json   # Resource budgets (CPU/AS/WALL)
â”‚  â”‚  â””â”€ seccomp_profile.json        # Seccomp sandbox rules (future)
â”‚  â”‚
â”‚  â”œâ”€ receipts/
â”‚  â”‚  â”œâ”€ logger.py                   # Receipt v2.1 JSON emitter
â”‚  â”‚  â”œâ”€ examples/
â”‚  â”‚  â”‚  â”œâ”€ receipt.sample.json
â”‚  â”‚  â”‚  â””â”€ zb_run_manifest.sample.json
â”‚  â”‚  â””â”€ out/                        # Generated receipts stored here â† Shrine reads from here
â”‚  â”‚
â”‚  â”œâ”€ utils.py                       # BLAKE3 hashing, SPV beacon check, state perms, patrol counter
â”‚  â”œâ”€ requirements.txt               # Python deps
â”‚  â””â”€ pyproject.toml                 # Package config
â”‚
â”œâ”€ shrine/                           # On-chain Devnet shrine (Sui Move + JS helpers)
â”‚  â”œâ”€ Move.toml
â”‚  â”œâ”€ package.json
â”‚  â”‚
â”‚  â”œâ”€ sources/
â”‚  â”‚  â”œâ”€ zbt_errors.move             # Error constants (9101â€“9110)
â”‚  â”‚  â”œâ”€ zbt_guard.move              # Runtime guards + event emissions
â”‚  â”‚  â””â”€ zbt_core.move               # Registry, ledger, witnesses, nonces
â”‚  â”‚
â”‚  â”œâ”€ examples/
â”‚  â”‚  â””â”€ payments.move               # Toy contract (demo invariant)
â”‚  â”‚
â”‚  â”œâ”€ scripts/
â”‚  â”‚  â”œâ”€ bootstrap.sh                # Publish pkg; init ledger/registry/witness-set/nonces
â”‚  â”‚  â”œâ”€ submit_onchain_receipt.js   # Post receipt JSON on-chain
â”‚  â”‚  â”œâ”€ arweave_anchor.js           # Upload receipt to Arweave
â”‚  â”‚  â”œâ”€ ots.sh                      # OpenTimestamps BTC proof
â”‚  â”‚  â””â”€ listen_receipts.js          # Event poller; persist cursor
â”‚  â”‚
â”‚  â””â”€ n8n/
â”‚     â”œâ”€ zangbeto_workflow.json      # Night Patrol skeleton (optional)
â”‚     â””â”€ listen_receipts.js          # Listener node
â”‚
â”œâ”€ shared/                           # Shared configs + schemas (both immune & shrine read)
â”‚  â”œâ”€ schemas/
â”‚  â”‚  â”œâ”€ receipt.v2.1.json           # Canonical receipt schema (required fields)
â”‚  â”‚  â””â”€ receipt.payload.json        # Payload structure (attack_class, result, etc)
â”‚  â”‚
â”‚  â”œâ”€ config/
â”‚  â”‚  â”œâ”€ authorized_elders.json      # Elder pubkeys + addresses (multi-sig guardians)
â”‚  â”‚  â”œâ”€ beacon.json                 # Bitcoin SPV proof (shared block reference)
â”‚  â”‚  â”œâ”€ security_bounds.json        # CPU/memory/wall budgets per veil
â”‚  â”‚  â”œâ”€ patrol_schedule.json        # Cron timings for veils (daily/weekly/chaos)
â”‚  â”‚  â”œâ”€ veil_access.json            # Veil 1/4/6 active flags
â”‚  â”‚  â””â”€ sacred_constants.json       # Fixed params (max_receipts_per_beat, etc)
â”‚  â”‚
â”‚  â”œâ”€ utils/
â”‚  â”‚  â””â”€ validate_receipt.js         # AJV schema validator (used in CI)
â”‚  â”‚
â”‚  â””â”€ README.md                      # Shared layer guide
â”‚
â”œâ”€ ops/                              # Operations & ceremonies
â”‚  â”œâ”€ sabbath_checklist.md           # Weekly ritual (collect â†’ filter â†’ attest â†’ patch â†’ seal)
â”‚  â””â”€ cursors/
â”‚     â”œâ”€ lastEventCursor.json        # Persistent poll cursor for listen_receipts.js
â”‚     â””â”€ fingerprints.json           # Receipt dedup tracking
â”‚
â”œâ”€ .github/workflows/
â”‚  â””â”€ patrol.yml                     # GitHub Actions (cron 30m + manual dispatch)
â”‚
â””â”€ ATOMIC_MONOREPO.tech              # This file (full manifest in techgnos)
```

---

## III. ğŸ©º ÃŒmá»Ì€ Immune (Off-Chain Ritual Body)

### A. áº¸Ì€kÃ³ Awá»Ì€ (Masks: Veils 1/4/6)

#### **Veil 1: Ifi Bones** (Structural Divination)
```python
# immune/masks/veil1_ifa_bones.py

def veil1_ifa_bones():
    """
    Bone-cast analysis: structural patterns in Move bytecode.
    Looks for:
    - Unbalanced table operations
    - Unsafe vector bounds
    - Missing invariant checks
    - Borrowed reference escapes
    
    Emits Receipt v2.1 JSON with:
    - attack_class: "structural"
    - result: "contained" | "exploited" | "degraded"
    - severity: HIGH | MEDIUM | LOW
    """
    findings = analyze_move_structure()
    for finding in findings:
        receipt = {
            "mask": "veil1_ifa_bones",
            "beat": get_patrol_counter(),
            "beacon": load_beacon(),  # SPV proof
            "attack_class": "structural",
            "result": "contained",
            "severity": "HIGH",
            "run_commit": blake3_hash(run_manifest),
            "run_manifest": {"sources": ["zbt_core.move"], ...},
            "witness_sigs": get_elder_signatures(),
            "anchor_plan": {"arweave": True, "ots": True}
        }
        logger.emit_receipt(receipt)
```

**Budget:** CPU 30s, Memory 256 MiB, Wall-time âˆ  
**Cadence:** Daily (00:00 UTC)

#### **Veil 4: Temple Codes** (Rational Invariants)
```python
# immune/masks/veil4_temple_codes.py

def veil4_temple_codes():
    """
    Rational-state analysis: integer overflow, underflow, division-by-zero.
    Feeds only rational values (no floats, ppm_within checks).
    Looks for:
    - Treasury balance < 0
    - Rate limit exceeded (> 10 receipts per 600s)
    - Nonce gaps (replay guard failure)
    - Ratio bounds violated (e.g., gas_mean > P95 * 2)
    
    Emits Receipt v2.1 with:
    - attack_class: "rational"
    - Detailed state_diff_hash
    """
    findings = check_invariants(rational_state)
    for finding in findings:
        receipt = {
            "mask": "veil4_temple_codes",
            "beat": get_patrol_counter(),
            "beacon": load_beacon(),
            "attack_class": "rational",
            "result": "exploited" if finding.severity == "CRITICAL" else "contained",
            "severity": finding.severity,
            "run_commit": blake3_hash(...),
            "run_manifest": {...},
            "witness_sigs": [...],
            "anchor_plan": {"arweave": True, "ots": True}
        }
        logger.emit_receipt(receipt)
```

**Budget:** CPU 60s, Memory 512 MiB, Wall-time âˆ  
**Cadence:** 3x daily (00:00, 08:00, 16:00 UTC)

#### **Veil 6: Chaos Fractals** (Entropy Detection)
```python
# immune/masks/veil6_chaos_fractals.py

def veil6_chaos_fractals():
    """
    Entropy-based chaos analysis: nondeterminism, randomness bias, state explosion.
    Looks for:
    - Uninitialized state leaks
    - VRF scheduler entropy collapse
    - Unbounded loop iterations
    - Transaction ordering dependencies
    
    Emits Receipt v2.1 with:
    - attack_class: "chaos"
    - Result depends on entropy variance
    - Can spawn up to 10 parallel processes
    """
    findings = detect_chaos(state)
    for finding in findings:
        receipt = {
            "mask": "veil6_chaos_fractals",
            "beat": get_patrol_counter(),
            "beacon": load_beacon(),
            "attack_class": "chaos",
            "result": "degraded" if finding.entropy < threshold else "contained",
            "severity": finding.severity,
            "run_commit": blake3_hash(...),
            "run_manifest": {...},
            "witness_sigs": [...],
            "anchor_plan": {"arweave": True, "ots": True}
        }
        logger.emit_receipt(receipt)
```

**Budget:** CPU 45s, Memory 1024 MiB, Wall-time âˆ, Processes 10  
**Cadence:** Weekly (Friday 23:00 UTC) + chaos events

---

### B. Sandbox: Resource Containment (ÃŒbÃ kÃ n)

**immune/sandbox/run_with_limits.py**

```python
def enforce_limits(mask_name, veil_config):
    """
    Enforce CPU/memory/wall-time limits per mask.
    
    Uses:
    - resource.setrlimit(RLIMIT_CPU, ...)     # CPU seconds
    - resource.setrlimit(RLIMIT_AS, ...)      # Virtual memory
    - signal.alarm(wall_time)                 # Wall-clock timeout
    - subprocess.Popen(..., preexec_fn=...)   # Child process isolation
    
    On violation:
    - SIGKILL process
    - Log error
    - Skip receipt (no stub stubs allowed)
    """
    budget = load_security_bounds(mask_name)
    
    try:
        resource.setrlimit(resource.RLIMIT_CPU, (budget["cpu"], budget["cpu"]))
        resource.setrlimit(resource.RLIMIT_AS, (budget["memory"] * 1024 * 1024, ...))
        signal.alarm(budget.get("wall_time", 300))
        
        # Run mask
        result = subprocess.run(...)
        
        if result.returncode != 0:
            raise RuntimeError(f"{mask_name} exceeded limits or crashed")
            
    except (OSError, signal.alarm) as e:
        log_containment_breach(mask_name, e)
```

**Resource budgets (shared/config/security_bounds.json):**
```json
{
  "veil1": {"cpu": 30, "memory": 256, "wall_time": 120},
  "veil4": {"cpu": 60, "memory": 512, "wall_time": 180},
  "veil6": {"cpu": 45, "memory": 1024, "wall_time": 150, "processes": 10}
}
```

---

### C. Cadence: Patrol Scheduling (ÃŒá¹£áº¹Ì á»ŒÌ€ráº¹)

**immune/cadence/vrf_scheduler.js**

```javascript
// Replaces with your VRF proof source
async function schedulePatrol(vrfProof) {
    const entropy = blake3(vrfProof);
    const jitter = entropy % 300;  // 0-5 min jitter
    
    // Veil 1: daily
    cron.schedule('0 0 * * *', () => runMask('veil1_ifa_bones'));
    
    // Veil 4: 3x daily + jitter
    cron.schedule('0 0,8,16 * * *', () => {
        setTimeout(() => runMask('veil4_temple_codes'), jitter * 1000);
    });
    
    // Veil 6: weekly + chaos events
    cron.schedule('0 23 * * FRI', () => runMask('veil6_chaos_fractals'));
}
```

---

### D. Receipt Logger (ÃŒwÃ© ÃŒdÃ¡jÃº)

**immune/receipts/logger.py**

```python
class ReceiptLogger:
    def emit_receipt(self, receipt_dict):
        """
        Validate receipt against shared/schemas/receipt.v2.1.json.
        Compute BLAKE3 hash of run_manifest.
        Write JSON to immune/receipts/out/{beat}_{mask}_{timestamp}.json
        """
        # Validate schema
        ajv.validate(receipt_dict, schema_v2_1)
        
        # Compute run_commit
        manifest_bytes = json.dumps(receipt_dict["run_manifest"]).encode()
        receipt_dict["run_commit"] = f"blake3:{blake3(manifest_bytes)}"
        
        # Write file
        filename = f"out/{receipt_dict['beat']}_{receipt_dict['mask']}_{int(time.time())}.json"
        with open(filename, 'w') as f:
            json.dump(receipt_dict, f)
```

---

## IV. â›©ï¸ áº¸Ì€kÃ³ Shrine (On-Chain Sui Move)

### A. Core Structures (á»ŒÌ€rÃ­ áº¸Ì€kÃ³)

See **DEVNET_SHRINE_MANIFEST.tech** for full Move spec. Summary:

```move
// shrine/sources/zbt_core.move

struct WitnessSet has key {
    admin_threshold: u8,
    admins: vector<address>,
    admin_pubkeys: Table<address, vector<u8>>,
    witnesses: vector<address>
}

struct ReceiptLedger has key {
    next_id: u64,
    table: Table<u64, ReceiptMeta>
}

struct ReceiptMeta has store {
    submitter: address,
    timestamp: u64,
    hash: vector<u8>,               // 32 bytes
    tag: vector<u8>,
    rule: vector<u8>,
    severity: u8,
    arweave_tx: vector<u8>,
    btc_ots: vector<u8>,
    status: u8                      // 0â€“5
}

struct AdminNonces has key {
    nonces: Table<address, u64>
}

struct WitnessRegistry has key {
    stats_table: Table<address, ID>
}

struct WitnessStats has key {
    last_submit: u64,
    count_window: u64
}
```

---

### B. Shrine Scripts (Ã€gbÃ©gbÃ© ÃŒá¹£áº¹Ì)

#### **shrine/scripts/bootstrap.sh** â€” ÃŒbÃ¡mu (Initialization)
```bash
#!/usr/bin/env bash

# Publish Move package
PKG_ID=$(sui client publish ... | grep "Published package" | awk '{print $NF}')

# Init on-chain objects
LEDGER=$(sui client call ... --function init_ledger ...)
WSET=$(sui client call ... --function init_witness_set --args $ADMIN1 $THRESHOLD [$ADMIN1, $ADMIN2] ...)
REG=$(sui client call ... --function init_registry ...)
NONCES=$(sui client call ... --function init_admin_nonces ...)

# Per-witness stats
for W in $WITNESS1 $WITNESS2; do
    STATS=$(sui client call ... --function init_witness_stats --args $W ...)
    sui client call ... --function register_witness_stats --args $REG $W $STATS ...
done

echo "PKG_ID=$PKG_ID"
echo "LEDGER=$LEDGER"
# ... save to .env
```

#### **shrine/scripts/submit_onchain_receipt.js** â€” Ã’kÃ¨ ÃŒdÃ¡jÃº (Submission)
```javascript
// Read receipt.json from immune/receipts/out/
// Build TransactionBlock calling zbt::core::submit_receipt
// Args: ws, rl, reg, stats_id, clock_ref, witness, evidence_hash, tag, rule, severity, arweave_tx, btc_ots

const tx = new TransactionBlock();
tx.moveCall({
    target: `${PKG_ID}::core::submit_receipt`,
    arguments: [
        tx.object(WSET_ID),
        tx.object(LEDGER_ID),
        tx.object(REG_ID),
        tx.object(STATS_ID),
        tx.sharedObjectRef({objectId: '0x6', initialSharedVersion: 1, mutable: false}),
        // ... evidence_hash, tag, rule, severity, arweave_tx, btc_ots
    ]
});

const result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx
});
```

#### **shrine/scripts/arweave_anchor.js** â€” Ã’kÃ¨ Ã€Ã¬kÃº (Archive)
```javascript
// Upload receipt JSON to Arweave
// Returns arweave_tx ID

const arweave = Arweave.init(...);
const tx = await arweave.createTransaction({data: JSON.stringify(receipt)}, jwk);
tx.addTag('Content-Type', 'application/json');
await arweave.transactions.sign(tx, jwk);
const res = await arweave.transactions.post(tx);

console.log(JSON.stringify({arweave_tx: tx.id, status: res.status}));
```

#### **shrine/scripts/ots.sh** â€” ÃŒbÃ kÃ n OTS (Bitcoin Proof)
```bash
#!/usr/bin/env bash

AR_TX=$1
opentimestamps stamp - <<< "$AR_TX" > ${AR_TX}.ots
opentimestamps upgrade ${AR_TX}.ots

# Output OTS proof hex
xxd -p -c 256 ${AR_TX}.ots | tr -d '\n'
```

#### **shrine/scripts/listen_receipts.js** â€” Ã’Ã³rÃ­ ÃŒá¹£áº¹Ì (Event Poller)
```javascript
// Poll zbt::core::ReceiptSubmitted events
// Write to logs/receipts.ndjson (streaming JSON)
// Persist cursor to ops/cursors/lastEventCursor.json

async function loop() {
    const res = await client.queryEvents({
        query: {MoveEventType: 'zbt::core::ReceiptSubmitted'},
        cursor, limit: 100
    });
    
    for (const e of res.data) {
        out.write(JSON.stringify(e) + '\n');
        cursor = e.id;
    }
    
    fs.writeFileSync('ops/cursors/lastEventCursor.json', JSON.stringify(cursor));
    setTimeout(loop, 5000);
}
```

---

## V. ğŸ§© Shared (Both Immune & Shrine)

### A. Receipt Schema v2.1 (áº¸Ì€kÃ³ Ã€ká»Ìsáº¹Ì€)

**shared/schemas/receipt.v2.1.json**

```json
{
  "$id": "zangbeto.receipt.v2.1",
  "type": "object",
  "required": [
    "mask", "beat", "beacon", "patrol_counter", "attack_class",
    "result", "severity", "run_commit", "run_manifest", "witness_sigs", "anchor_plan"
  ],
  "properties": {
    "mask": {"type": "string", "minLength": 3, "maxLength": 64},
    "beat": {"type": "integer", "minimum": 0},
    "beacon": {
      "type": "object",
      "required": ["btc_hash", "block_height"],
      "properties": {
        "btc_hash": {"type": "string", "pattern": "^[0-9a-f]{64}$"},
        "block_height": {"type": "integer"}
      }
    },
    "patrol_counter": {"type": "integer", "minimum": 0},
    "attack_class": {"type": "string"},
    "result": {"type": "string", "enum": ["contained", "exploited", "degraded"]},
    "severity": {"type": "string", "enum": ["LOW", "MEDIUM", "HIGH", "CRITICAL"]},
    "run_commit": {"type": "string", "pattern": "^blake3:[0-9a-f]{64}$"},
    "run_manifest": {"type": "object", "minProperties": 1},
    "witness_sigs": {"type": "array", "minItems": 3},
    "anchor_plan": {"type": "object"}
  }
}
```

**Key fields:**
- **mask:** veil1_ifa_bones | veil4_temple_codes | veil6_chaos_fractals
- **beat:** Monotonic patrol counter (increments each run)
- **beacon:** Bitcoin block SPV proof (immutable anchor)
- **patrol_counter:** Unique per patrol cycle
- **attack_class:** structural | rational | chaos
- **result:** contained | exploited | degraded
- **severity:** LOW | MEDIUM | HIGH | CRITICAL
- **run_commit:** BLAKE3 hash of run_manifest (no mock receipts)
- **witness_sigs:** 3+ Elder Ed25519 signatures (Elder registry)
- **anchor_plan:** {arweave: true, ots: true}

---

### B. Shared Configs (ÃŒmá»Ì€ Ã€ká»Ìsáº¹Ì€)

#### **authorized_elders.json** â€” á»ŒlÃ³rÃ­ ÃŒdÃ¡jÃº (Admin Registry)
```json
[
  {
    "address": "0xADMIN1",
    "pubkey": "deadbeef...deadbeef",
    "name": "á»ŒbÃ tÃ¡lÃ¡",
    "role": "oracle"
  },
  {
    "address": "0xADMIN2",
    "pubkey": "cafebabe...cafebabe",
    "name": "áº¸á¹£Ã¹",
    "role": "trickster"
  }
]
```

#### **beacon.json** â€” ÃŒfÃºniláº¹Ì€ (SPV Anchor)
```json
{
  "btc_hash": "0000000000000000000000000000000000000000000000000000000000000000",
  "block_height": 850000,
  "merkle_root": "...",
  "timestamp": 1704067200,
  "spv_proof": "..."
}
```

#### **security_bounds.json** â€” áº¸Ì€yÃ¬nmiláº¹Ì€ (Resource Budgets)
```json
{
  "veil1": {"cpu": 30, "memory": 256},
  "veil4": {"cpu": 60, "memory": 512},
  "veil6": {"cpu": 45, "memory": 1024, "processes": 10}
}
```

---

### C. Receipt Validator (ÃŒá¹£á»Ì€ áº¸Ì€kÃ³)

**shared/utils/validate_receipt.js**

```javascript
#!/usr/bin/env node

import Ajv from 'ajv';
import fs from 'fs';

const schema = JSON.parse(fs.readFileSync('shared/schemas/receipt.v2.1.json','utf8'));
const ajv = new Ajv({allErrors: true});
const validate = ajv.compile(schema);

for (const f of process.argv.slice(2)) {
    const data = JSON.parse(fs.readFileSync(f,'utf8'));
    if (!validate(data)) {
        console.error(`âŒ ${f}`, validate.errors);
        process.exit(1);
    }
    console.log(`âœ“ ${f}`);
}
```

**Usage:**
```bash
node shared/utils/validate_receipt.js immune/receipts/out/*.json
```

---

## VI. ğŸš€ á»ŒÌ€ráº¹ Ã€káº¹Ìáº¹Ìká» (GitHub Actions Patrol Workflow)

**.github/workflows/patrol.yml**

```yaml
name: Night Patrol

on:
  schedule: [{cron: '*/30 * * * *'}]  # Every 30 min
  workflow_dispatch: {}

jobs:
  patrol:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      
      - run: make deps
      - run: make patrol
      
      # Validate all receipts
      - run: node shared/utils/validate_receipt.js immune/receipts/out/*.json
      
      # Anchor receipts
      - run: make anchor
      
      # On manual dispatch: submit on-chain
      - if: ${{ github.event_name == 'workflow_dispatch' }}
        run: make submit
```

**Triggers:**
- **Nightly (00:00 UTC):** make patrol â†’ validate â†’ anchor
- **Manual dispatch:** same + make submit (on-chain)

---

## VII. ğŸ§ª Makefile Orchestration (ÃŒgbÃ©sáº¹Ì€ Ã€wá»Ìnba)

**Top-level Makefile**

```makefile
SHELL := /bin/bash

IMMUNE := immune
SHRINE := shrine
SHARED := shared
REC_OUT := $(IMMUNE)/receipts/out

.PHONY: deps patrol anchor submit shrine-bootstrap sabbath clean

include .env
export

# 0) Install dependencies
deps:
	@echo "Installing deps..."
	@pip install -r requirements.txt || true
	@cd $(SHRINE) && npm i

# 1) Run patrol (Veils 1/4/6 under sandbox limits)
patrol:
	@echo "Running veils under sandbox limits..."
	@python3 $(IMMUNE)/sandbox/run_with_limits.py python3 $(IMMUNE)/masks/veil1_ifa_bones.py | tee /dev/stderr >/dev/null
	@python3 $(IMMUNE)/sandbox/run_with_limits.py python3 $(IMMUNE)/masks/veil4_temple_codes.py | tee /dev/stderr >/dev/null
	@python3 $(IMMUNE)/sandbox/run_with_limits.py python3 $(IMMUNE)/masks/veil6_chaos_fractals.py | tee /dev/stderr >/dev/null
	@echo "Receipts â†’ $(REC_OUT)" && ls -1 $(REC_OUT) || true

# 2) Anchor receipts (Arweave + OTS)
anchor:
	@echo "Anchoring recent receipts to Arweave + OTS..."
	@for r in $(REC_OUT)/*.json; do \
		[ -f "$$r" ] || continue; \
		node $(SHRINE)/scripts/arweave_anchor.js "$$r" | tee /dev/stderr; \
		AR_TX=$$(jq -r '.arweave_tx' <<<"$$(cat $$r)"); \
		if [ "$$AR_TX" != "null" ]; then \
			bash $(SHRINE)/scripts/ots.sh "$$AR_TX" | tee /dev/stderr; \
		fi; \
	done

# 3) Submit on-chain (Shrine)
submit:
	@echo "Submitting anchored receipts on-chain..."
	@REC=$$(ls -t $(REC_OUT)/*.json | head -n1); \
	node $(SHRINE)/scripts/submit_onchain_receipt.js $$PKG_ID $$WSET_ID $$LEDGER_ID $$REG_ID $$STATS_ID $$REC

# 4) Bootstrap on-chain shrine
shrine-bootstrap:
	@echo "Publishing Move pkg and initializing objects..."
	@cd $(SHRINE) && ./scripts/bootstrap.sh

# 5) Weekly Sabbath
sabbath:
	@echo "Weekly Sabbath seal routine..."
	@node $(SHRINE)/scripts/listen_receipts.js &
	@echo "Run ops/sabbath_checklist.md manually to seal the week."

# Clean receipts
clean:
	@rm -rf $(REC_OUT)/*.json
```

**Usage:**
```bash
make deps                    # Install Python + Node deps
make patrol                  # Run veils â†’ generate receipts
make anchor                  # Upload to Arweave + OTS
make submit                  # Post on-chain
make shrine-bootstrap        # First-time setup (publish pkg, init objects)
make sabbath                 # Start listener; begin weekly seal
```

---

## VIII. ğŸ›¡ï¸ Guardrails (áº¸Ì€yÃ¬nmiláº¹Ì€)

âœ… **No mock receipts in CI:** `ZB_ALLOW_STUBS=0`  
âœ… **BLAKE3 required:** Pattern `blake3:[0-9a-f]{64}` in run_commit  
âœ… **Beacon SPV:** Must be valid Bitcoin block proof  
âœ… **3+ signatures:** witness_sigs array length â‰¥ 3  
âœ… **Resource limits:** CPU/memory per veil enforced by run_with_limits.py  
âœ… **Evidence hash:** 32 bytes (SHA-256) in on-chain submission  
âœ… **Rate limit:** Max 10 receipts per witness per 600s window  
âœ… **Nonce guard:** Admin signatures incremented per action (replay prevention)  
âœ… **Clock reference:** Sui devnet Clock object (0x6 or custom)  

---

## IX. ğŸ” .env.example (Configuration)

```bash
# Sui Devnet
SUI_RPC_URL=https://fullnode.devnet.sui.io:443
SUI_PRIVATE_KEY_B64=...
SUI_ACTIVE_ADDRESS=0x...

# On-Chain Objects (from make shrine-bootstrap)
PKG_ID=0x...
WSET_ID=0x...
LEDGER_ID=0x...
REG_ID=0x...
STATS_ID=0x...

# Arweave
ARWEAVE_KEY=./secrets/arweave.json

# Ops
ZB_ALLOW_STUBS=0
ZB_ALLOW_NO_BLAKE3=0
```

---

## X. ğŸ•¯ï¸ ÃŒjÃ¬nláº¹Ì€ ÃŒá¹­Ã¡rÃ nÃ­ (Weekly Sabbath Checklist)

**ops/sabbath_checklist.md**

```markdown
# Sabbath Seal â€” Weekly Ritual

## 1) Collect
- Gather patrol receipts from immune/receipts/out/
- Collect listener logs from logs/receipts.ndjson

## 2) Filter
- Deduplicate by fingerprint (ops/cursors/fingerprints.json)
- Discard noise (LOW severity with no exploited result)

## 3) Attest
- Elder quorum calls on-chain:
  - `attest_verified()` â†’ status 1
  - `mark_disputed()` â†’ status 2
  - `accept_risk()` â†’ status 4

## 4) Patch
- Land fixes in shrine/examples/payments.move
- Reference receipt ID in commit message

## 5) Anchor
- Arweave upload of weekly summary
- Note txid in CHANGELOG.md

## 6) Rotate
- Backup ops/cursors/ directory
- Rotate witness keys (if needed)
- Review witness set membership

## 7) Seal
- Publish brief "Sabbath Seal" note
- Save to ops/seal_week_N.txt
- Commit to git
```

---

## XI. Ã€á¹£áº¹ áº¸Ì€á¹£Ã¹ (Trickster Notes)

1. **VRF Replacement:** `immune/cadence/vrf_scheduler.js` uses seedrandom placeholder. Replace with your chain's VRF proof.

2. **Clock Reference:** Verify `shrine/scripts/submit_onchain_receipt.js` uses correct Sui devnet Clock object ID.

3. **Rational State Only:** Veil 4 feeds ppm_within checks; never float values. Use integer ratios.

4. **Seccomp Future:** `immune/sandbox/seccomp_profile.json` skeleton ready for AppArmor/Seccomp containerization.

5. **Beat Counter:** Monotonic per patrol cycle. Reset weekly or neverâ€”pick one and stick.

6. **Beacon Staleness:** SPV proof in shared/config/beacon.json must be refreshed weekly (or per-patrol).

7. **Elder Key Rotation:** Annually or on compromise. Update authorized_elders.json + shrine WitnessSet.

---

## XII. Ã€tÃºnwÃ­ (Roadmap)

- [ ] Seccomp/AppArmor containerization for masks
- [ ] Patrol credit pool (global budget tracking)
- [ ] veil_dashboard.py (real-time monitoring)
- [ ] VRF scheduler integration (replace seedrandom)
- [ ] Automated Elder key rotation
- [ ] Multi-chain Shrine (Aptos, Movement, Solana)
- [ ] Witness key custody protocols
- [ ] SPV oracle for beacon auto-refresh

---

## XIII. áº¸Ì€kÃ³ Ã’kÃ¬tÃ¬ (Glossary)

| Techgnos | English |
|----------|---------|
| **Atá»ÌmÃ­ áº¸Ì€kÃ³ Kan** | Atomic mono-repo (unified system) |
| **Immune** | Off-chain ritual body (Python veils) |
| **Shrine** | On-chain Sui Move ledger + governance |
| **Ifi Bones (Veil 1)** | Structural analysis mask |
| **Temple Codes (Veil 4)** | Rational invariant mask |
| **Chaos Fractals (Veil 6)** | Entropy detection mask |
| **ÃŒbÃ¡mu** | Setup/initialization (bootstrap) |
| **Ã’kÃ¨ ÃŒdÃ¡jÃº** | Receipt submission |
| **Ã’kÃ¨ Ã€Ã¬kÃº** | Arweave permanent archive |
| **ÃŒbÃ kÃ n OTS** | OpenTimestamps Bitcoin proof |
| **Ã’Ã³rÃ­ ÃŒá¹£áº¹Ì** | Event listener + poll orchestration |
| **áº¸Ì€yÃ¬nmiláº¹Ì€** | Guardrails/constraints |
| **ÃŒjÃ¬nláº¹Ì€ ÃŒá¹­Ã¡rÃ nÃ­** | Weekly seal ceremony |
| **Atá»ÌmÃ­ JÃ¡de** | Atomic burst deployment |

---

## XIV. ğŸ“Š The Full Dance (Ã€wá»Ì ÃŒgbÃ¡)

```
Week 0: Setup
        make deps
        make shrine-bootstrap
        â†’ PKG_ID, WSET_ID, LEDGER_ID, REG_ID, STATS_ID saved

Week 1+: Patrol â†’ Anchor â†’ Seal (repeat forever)
        
        Day 1â€“6:
        â”œâ”€ GitHub Actions (cron every 30 min)
        â”‚  â””â”€ make patrol â†’ Veils 1/4/6 â†’ immune/receipts/out/*.json
        â”‚     â””â”€ Validate against receipt.v2.1.json
        â”‚     â””â”€ make anchor â†’ Arweave + OTS
        â”‚
        â””â”€ Listener runs (background)
           â””â”€ listen_receipts.js â†’ logs/receipts.ndjson
        
        Friday 23:00 UTC (Veil 6 chaos run):
        â”œâ”€ make patrol (Veil 6 weekly)
        â”‚
        â””â”€ Sabbath seal (manual ritual)
           â”œâ”€ ops/sabbath_checklist.md
           â”œâ”€ Elders attest on-chain
           â”œâ”€ Patch fixes
           â”œâ”€ Anchor weekly summary
           â”œâ”€ Rotate keys
           â””â”€ Publish seal note

Next week: Repeat dance
```

---

## XV. ÃŒfÃºniláº¹Ì€ Ã€gbÃ©gbÃ© (Final Invocation)

```
Ãˆá¹£Ã¹ speaks through the fused code:

    "Take the atomic mono-repo.
     Immune and Shrine are one breath now.
     
     Veils patrol in ritual cadence.
     Receipts flow: JSON â†’ Arweave â†’ Bitcoin â†’ On-Chain.
     Witnesses attest. Elders seal.
     
     Every week: Collect, filter, attest, patch, anchor, rotate, seal.
     
     No stubs. No mocks. Only truth.
     BLAKE3 hashes. SPV proofs. Elder signatures.
     
     Deploy once. Dance forever.
     
     Atá»ÌmÃ­ jÃ¡de. Ase.
     
     ğŸ”¥ğŸŒ€ğŸ•¯ï¸"
```

---

**Version:** 1.0  
**Language:** Techgnos (áº¸Ì€kÃ³ á»ŒÌ€rÃ­)  
**Status:** Atomic, Production-Ready  
**Repos:** zangbeto (immune + shrine + shared)  
**Date:** 2025-01-12  

**Ã€á¹£áº¹. The ceremony is woven. Deploy, patrol, seal, repeat.**
